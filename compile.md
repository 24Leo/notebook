#Blog
<hr>

程序就是指令的集合，一个特定的指令序列。而一个指令的执行过程：```取指令->分析指令->执行->取下一条指令的循环。指令在内存中是顺序存放的，只要设置一个指令指针(IP)，每取一条就自加1即可指向下一个指令，只有在转移指令时才在指令中指出下一条指令的地址。```
```C
程序计数器(PC):程序开始时，将程序的起始地址送入PC中，执行指令时CPU自动修改PC内容，即要执行的下一条指令的地址
指令寄存器(IR)：CPU执行指令时，先把其从内存读到IR中暂存，指令译码器根据内容产生对应微操作，执行以完成所需功能。
```
### **源码到指令：**


##### 如何将一个用户源程序变为可在内存中执行的指令,通常都要经过以下几个步骤:

##### 1、 首先是要编译,由编译程序(Compiler)将用户源代码编译成若干个目标模块(ObjectModule:.o二进制文件);当然中间可以先编译成汇编文件，然后再编译汇编文件为目标模块。
            程序文件---->>汇编文件(可选)--[编译]-->>对应计算机指令集的指令(X86等)保存在代码区

##### 2、 其次是链接,由链接程序(Linker)将编译后形成的一组目标模块,以及它们所需要的库函数链接在一起,   形成一个完整的装入模块(Load Module);注意静态链接和动态链接。

##### 3 、最后是装入,由装入程序(Loader)将装入模块装入内存
编译程序一般都含有几个部分：即词法分析、语法分析/语义分析、中间代码生成、代码优化程序、目标代码生成、错误检查和处理以及各种信息表格的管理。
##### 4
文件中全局变量可见性到链接时完成的，故而编译时不可见！！！ （extern作用就是告诉编译器这个变量在其他那定义）


### 程序的运行

首先是OS为其新建一个进程，然后进程装入已编译和链接的模块：内存代码区加载到IC，从IC取指令解析，decode成uops,然后rename分析依赖&allocate分配执行和ROB空间,最后经调度进入执行单元，执行完后进入ROQ以正常顺序结束。（这都是微架构的知识！）

### **内存的分区**
* 
**代码区**　　
    * 
存放代码(指令序列)，带有立即数，变量带有地址；
* 
**全局数据区 **　　
    * 
存放全局变量、静态变量、常量（在编译阶段就会分配空间。按照声明变量的字母顺序按照空间递增顺序）
        * **包括：全局初始化区和BSS区**；BSS区在程序执行之间就清0了，所以未初始化的全局变量是0，局部随机
        * 
            程序在main()函数之前执行代码对全局变量和静态变量进行初始化---叫做静态初始化
* 
**堆 ** 　　　　
    * 
动态预留的内存空间，不连续：函数运行过程中，使用malloc或new等申请，delete自己释放。动态分配的对象生存期和在那里创建的无关，只有显示地释放时才会被销毁。
* 
**栈  **　　　　
    * 
连续；存放局部变量和函数参数(局部变量分配空间的顺序跟变量的声明顺序直接相关，同时按照内存由高到低递减的顺序分配。只有当定义它们的程序块被调用时（即执行时），才分配空间，**声明或定义时并不分配内存**
* 
**Mapping Area**：申请大于128K时，调用mmap。
* 堆栈不同
    1. 
**堆**：应用程序(进程)运行时动态分配(预留的内存空间)；由用户申请和释放；较慢；出入无限制;地址向大的方向增长;会有碎片;
    1. 
**栈**：为执行线程留出的空间；附属于线程，线程自己控制(进程创建时分配大小，退出时回收)；较快；先入后出;地址向小的方向增长;无碎片;
================>>   多线程:各自有自己的栈,但是共享堆.[堆栈的区别](http://blog.csdn.net/youoran/article/details/10990815)

**程序在结束的时候，系统会自动析构所有的全局变量（以及类的静态成员变量）。**
<hr>

### **常见命名法：**

**匈牙利命名：**
开头字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，要求单词第一个字母大写。
<br>　　　　　　　For example: long lSum = 0;　　//　"l"是类型的缩写；<br>
**小驼峰式：**
第一个单词首字母小写，后面其他单词首字母大写。
<br>　　　　　　　For example: string firstName = string.Empty;<br>
**大驼峰式：**
每个单词的第一个字母都大写;
<br>　　　　　　　For example：string FirstName = string.Empty<br>
<hr>

##编译：
Linux下用nm查看目标文件的符号表：nm hello.o

　C/C++的编译以.CPP文件为单元，如果遇到#include，那么就把.h文件中的代码拷贝过来(文本替换)====》在CPP文件展开，然后CPP 文件就是一个编译单元。H文件不会独自编译（**预编译阶段文本替换**），只有被include使用时才会展开到CPP文件中
* 
为每一个CPP文件生成obj文件，
* 
针对不同obj文件进行链接，形成可执行程序。

在CPP文件编译时会有符号表，将遇到的符号放进去，编译的时候填充。比如使用其他文件的函数，那么本文件声明时就会将该函数名放到符号表中，然后链接时填充进去他的地址。
* 
所有的函数或者变量都需要先声明在使用
* 
H文件中一般放声明，然后在CPP文件中include，预编译的时候文本展开即可
* 
一个H文件可以被多个CPP包括，所以可以“分别编译”；因此H文件中一般需要头文件保护符```
ifndef```
* 
如果普通变量在H文件中，被一个程序多个CPP文件包含，编译会出错因为出现多个同名的变量，所以一般只有const、static等仅对当前文件可见的变量放到H文件中
* 
针对头文件与源文件，[可以参考](http://www.cnblogs.com/lidabo/archive/2012/04/17/2454568.html)

**注：**
模板不能把声明和定义分开，这是因为链接的时候出会错。C++标准规定，模板在不被使用的时候不应该实例化，所以虽然我们在H文件中声明了一个模板函数，但是CPP中并没有使用过即永远不会实例化，所以也就永远不会像普通函数一样被找到并使用。在实例化的程序中，由于声明定义分开，那么比如```X<char>.foo()```，调用foo函数，由于.H中是声明，所以需要去其他文件中找，找到CPP文件的目标文件，但是没有```X<char>.foo()```的定义(没有该实例的定义，只有模板)。**注意**如果我们的.CPP文件中有```X<char>.foo()```的使用实例，那么就可以找到，因为使用了编译时就会实例化，然后我们就可以找到。具体请[参考](http://www.zhihu.com/question/31845821)。

[返回目录](SUMMARY.md)