####1. 复制相关
众所周知，MySQL**只支持一对多的主从复制**，而不支持多主（multi-master）复制。 
* 
在有多个slave参与的半同步复制中，master并不一定需要等待全部slave返回
* 
MySQL使用多主复制时，需要修改自增长变量参数,所以有人认为不支持。
* 
一般情况下，异步复制的性能比半同步复制好，但后者相对更为安全<br>
**基于行的复制** MySQL 5.1 中，在复制方面的改进就是引进了新的复制技术.基于行的复制。
简言之，这种新技术就是关注表中发生变化的记录，而非以前的照抄** binlog 模式**。<br>
从 MySQL 5.1.12 开始，可以用以下三种模式来实现：
    * 
基于SQL语句的复制(statement-based replication, SBR)，
    * 
基于行的复制(row-based replication, RBR)，
    * 
混合模式复制(mixed-based replication, MBR)。<br>

相应地，binlog的格式也有三种：STATEMENT，ROW，MIXED。 MBR 模式中，SBR 模式是默认的。<br>
**Mysql复制分成三步：** 
* 
master将改变记录到**二进制日志(binary log ：BINLOG)**中（这些记录叫做二进制日志事件，binary log events）； 
* 
slave将master的binary log events拷贝到它的中继日志(relay log)； 
* 
slave重做中继日志中的事件，将改变反映它自己的数据。

####3. 事务：
是一系列的数据库操作，是数据库应用的基本逻辑单位。性质：
* 
原子性。即不可分割性，事务要么全部被执行，要么就全部不被执行。
* 
一致性。事务的执行使得数据库从一种正确状态转换成另一种正确状态
* 
隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，
* 
持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。
* 
开启事务：
    * 
显示开启： start transction | begin 
    * 
隐式：COMMIT、ROLLBACK


####4. 三范式：
* 
1NF:每个属性是不可分的。 
* 
2NF:若关系R是１NF,且每个非主属性都**完全函数依赖**于主键。例SLC(SID#, CourceID#, SNAME,Grade),则不是2NF;     ===》也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
* 
3NF:若R是2NF，且它的任何非键属性都不传递依赖于任何候选键（即非主键）。<br>
===》即每一列数据都和主键直接相关，而不能间接相关。<br>
**例子**
* 
不符合第一范式的例子(关系数据库中create不出这样的表)：
```表:字段1, 字段2(字段2.1, 字段2.2), 字段3 ......```
* 
不符合第二范式的例子:```表:学号, 姓名, 年龄, 课程名称, 成绩, 学分;``` ==》说明了两个事务:学生信息, 课程信息; <br>
**[存在问题](http://www.jb51.net/article/70867.htm):**
* 
数据冗余，每条记录都含有相同信息；
* 
删除异常：删除所有学生成绩，就把课程信息全删除了；
* 
插入异常：学生未选课，无法记录进数据库；
* 
更新异常：调整课程学分，所有行都调整。 

####4.1 键
    * #####4.1.1 主键
        * 设置某一列为主键，**用来唯一标识某一行**；
        * 一张表仅最多一个主键；
    * #####4.1.2 外键
        * 建立和其他表联系的一列或者多列；
        * 一个外键一定是另一张表的主键，用来维护两张表之间的一致性；
        * 外键要么为空，要么是主键的一个值；    
        * 要删除一个表主键之前一定要确定其他表外键已经被删除；
    * #####4.1.3 索引
        * 索引用来加快检索。一般起到排序作用。
        * 唯一索引和普通索引区别：值仅能出线一次，必须唯一；
        * 主键默认生成唯一索引。即主键也是一个特殊的索引；
    * #####4.1.4 总结
        * 主键一定是唯一索引，但反过来不一定；
        * 唯一索引可以有多个，但是主键只能一个；
        * 主键不可以为空，唯一索引可以
        * 主键可以和外键引用，索引不行

####5.  完整性约束：
* 
实体完整性：是指关系(所谓的关系就是表)的主码即主键不能取空值
* 
参照完整性：是指参照关系中每个元素的外码要么为空(NULL)，要么等于被参照关系中某个元素的主码；
* 
用户定义完整性：指对关系中每个属性的取值有一个限制(或称为约束)的具体定义。比如 性别属性只能取”男“或”女“  ；

####6. [索引作用](index.md)
CREATE [UNIQUE] INDEX 索引名称 ON 表名称 (列名称) 
<br>或者在列上直接写index
* 
作用：为每张表相当于添加一个目录，检索更快；索引是建立在数据库表中的某些列的上面。
* 
优点：
    * 
第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
    * 
第二，可以大大加快 数据的**检索速度**，这也是创建索引的最主要的原因。
    * 
第三，可以**加速表和表之间的连接**，特别是在实现数据的参考完整性方面特别有意义。
    * 
第四，在使用**分组和排序 子句**进行数据检索时，同样可以显著减少查询中分组和排序的时间。
    * 
第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 
* 
缺点：时间和空间
    * 
第一，创建索引和维护索引要**耗费时间**，这种时间随着数据 量的增加而增加。
    * 
第二，索引需要占**物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
    * 
第三，当对表中的数据进行增加、删除和修改的时候，**索引也要动态的维护**，这样就降低了数据的维护速度。 
* 
那些适合建索引：
    * 
在作为**主键的列**上，强制该列的唯一性和组织表中数据的排列结构；
    * 
在**经常用在连接**的列上，这 些列主要是一些外键，可以加快连接的速度；
    * 
在经常需要根**据范围进行搜索**的列上创建索引，因为索引已经排序，其指定的范围是连续的；
    * 
在经常**需要排序**的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
    * 
在经常使用**在WHERE子句中的列**上面创建索引，加快条件的判断速度。 
* 
那些不适合：
    * 
对于那些在查询**中很少使用**或者参考的列不应该创建索引。
    * 
对于那 些只**有很少数据值的列**也不应该增加索引。
    * 
对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 
    * 
**总的来说**：当修改性能远远大于检索性能时，不应该创建索 引。

####7. 内联接,外联接区别？
* 
内连接（inner join）是保证两个表**中所有的行都要满足连接条件**：典型的联接运算，使用像 =  或 < > 之类的比较运算符；
* 
在外连接中，某些不满条件的列也会显示出来，也就是说，只限制其中一个表的行，而不限制另一个表的行。分左连接、右连接、全连接三种：    
    * 
左连接（left join）：结果集包括  LEFT OUTER子句中指定**的左表的所有行**，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。
    * 
右连接（right join）：与左连接相似，只是如果右表对应的左表没有，则填充空，**右表的所有行**
    * 
全连接（full join ）：返**回左表和右表中的所有行**。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 
    * 
交叉连接（cross join） ：将两个表的所有行进行组合，连接后的行数为两个表的笛卡尔积数。
<br>
**例子**

| A表： | ID | Name | B表 | ID| Age | Pid |
| -- | -- | -- | -- | -- | -- | -- |
|  | 1 | 张三 |  | 1 | 52 | 1 |
|  | 2 | 李四 |  | 2 | 35 | 2 |
|  | 3 | 王武 |  | 3 | 64 | 4 |
A表ID与B表的Pid存在相关关系：
```SQL
1） 内连接 ：两张表完全匹配的几个数据集
      select   a.*,b.*   from   a   inner   join   b     on   a.id=b.parent_id      
      结果是    
      1   张3     1     23     1  
      2   李四    2     34     2  

2）左连接 ：左表的所有和右表的匹配，没有在右表匹配到的天NULL
      select   a.*,b.*   from   a   left   join   b     on   a.id=b.parent_id      
      结果是    
      1   张3     1     23     1  
      2   李四    2     34     2  
      3   王武    null  

3） 右连接 ：左表和右表所有匹配，左表没有的填NULL
      select   a.*,b.*   from   a   right   join   b     on   a.id=b.parent_id      
      结果是    
      1   张3    1     23     1  
      2   李四   2     34     2  
      null       3     34     4  

4） 完全连接 ：两张表的合集，对方没有的填NULL
      select   a.*,b.*   from   a   full   join   b     on   a.id=b.parent_id  
      结果是    
      1   张3     1     23     1  
      2   李四    2     34     2  
      null        3     34     4  
      3   王武    null
```


####8. 锁：共享锁、互斥锁
两段锁协议：阶段１：加锁阶段 阶段２：解锁阶段
* 
共享锁：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁，直到已释放所有共享锁。获准共享锁的事务只能读数据，不能修改数据。 
* 
互斥锁：如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的锁，直到在事务的末尾将资源上的锁释放为止。获准排他锁的事务既能读数据，又能修改数据。
* 
性能上，纯互斥锁比共享+互斥锁要快非常多
锁的底层实现一般是在C的库或者操作系统实现的，有些地方需要原子计数器或者内存栅这种机制。

####9. 死锁及处理：事务循环等待数据锁，则会死锁。

死锁处理：预防死锁协议，死锁恢复机制

####10. 视图
视图是从数据库的基本表中选取出来的数据组成的逻辑窗口，它是一个虚表，它包含的不是数据而是根据需要检索数据的查询。
```SQL
    CREATE VIEW ProductCustomers AS --视图必须唯一命名，创建视图  
    SELECT cust_name,cust_contact,prod_id  
    FROM Customers,Orders,OrderItems  
    WHERE Customers.cust_id=Orders.cust_id AND OrderItems.order_num=Orders.order_num;  
    
    #可以这样使用视图  
    SELECT*  
    FROM ProductCustomers  
    WHERE prod_id="RGAN01";  
```
* 
在数据库中，存放的只是视图的定义而已，不存放视图包含的数据，这些视图仍存放在原来的基本表结构中。
* 
引入视图机制，用户可以将注意力集中在其关心的数据上而非全部数据，提高了用户效率和用户满意度。

####11. MyISAM和InnoDB的区别
两种类型最主要的差别就是Innodb 支持**事务处理与外键和行级锁**。
* 
MySQL默认采用的是MyISAM。5.5开始默认innodb
* 
MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。
* 
InnoDB支持数据行锁定，MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。
* 
InnoDB支持外键，MyISAM不支持。
* 
InnoDB的主键范围更大，最大是MyISAM的2倍。
* 
InnoDB不支持全文索引，而MyISAM支持。全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。
* 
MyISAM支持GIS数据，InnoDB不支持。即MyISAM支持以下空间数据对象：Point,Line,Polygon,Surface等。
* 
没有where的count(\*)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(\*)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(\*)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count(\*)的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。

####12. [索引](http://blog.csdn.net/idber/article/details/8109522)的实现原理
B树及其变种B+树

####13. 

####14. 

####15. 


[返回目录](README.md)